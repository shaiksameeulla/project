 
 For information on bootstrapping Hibernate
 =========================================
1.For (semi-deprecated) bootstrapping of a SessionFactory using the legacy Configuration approach, see the Legacy Bootstrapping Guide
2.For bootstrapping a SessionFactory, see the Native Bootstrapping Guide
3.For bootstrapping a Hibernate EntityManagerFactory (JPA), see the JPA Bootstrapping Guide


Before we start exploring the new bootstrapping process, we need to add the hibernate-core jar file to the project classpath. In a Maven based project, we just need to declare this dependency in the pom.xml file:

<dependency>
    <groupId>org.hibernate</groupId>
    <artifactId>hibernate-core</artifactId>
    <version>5.4.0.Final</version>
</dependency>

As Hibernate is a JPA provider, this will also include the JPA API dependency transitively.


 
 Legacy Bootstrapping:
	 -------------------
	 The legacy way to bootstrap a SessionFactory is via the org.hibernate.cfg.Configuration object. Configuration represents, essentially, a single point for specifying all aspects of building the SessionFactory: everything from settings, to mappings, to strategies, etc. I like to think of Configuration as a big pot to which we add a bunch of stuff (mappings, settings, etc) and from which we eventually get a SessionFactory.
	 Note: Configuration is semi-deprecated but still available for use, in a limited form that eliminates these drawbacks. "Under the covers", Configuration uses the new bootstrapping code, so the things available there are also available here in terms of auto-discovery.
	 You can obtain the Configuration by instantiating it directly. You then specify mapping metadata (XML mapping documents, annotated classes) that describe your applications object model and its mapping to a SQL database.

			Configuration cfg = new Configuration()
				// addResource does a classpath resource lookup
				.addResource( "Item.hbm.xml" )
				.addResource( "Bid.hbm.xml" )

				// calls addResource using "/org/hibernate/auction/User.hbm.xml"
				.addClass( org.hibernate.auction.User.class )

				// parses Address class for mapping annotations
				.addAnnotatedClass( Address.class )

				// reads package-level (package-info.class) annotations in the named package
				.addPackage( "org.hibernate.auction" )

				.setProperty( "hibernate.dialect", "org.hibernate.dialect.H2Dialect" )
				.setProperty( "hibernate.connection.datasource", "java:comp/env/jdbc/test" )
				.setProperty( "hibernate.order_updates", "true" );

			There are other ways to specify Configuration information, including:

			Place a file named hibernate.properties in a root directory of the classpath
			Pass an instance of java.util.Properties to Configuration#setProperties
			Via a hibernate.cfg.xml file
			System properties using Java -Dproperty=value

		


Hibernate Native API for session factory
==================================

Bootstrap a Hibernate SessionFactory
 Use Hibernate mapping (hbm.xml) files to provide mapping information
 Use the Hibernate native APIs
 
 The mapping file:
 ----------------
The mapping file for this tutorial is the classpath resource org/hibernate/tutorial/hbm/Event.hbm.xml (as discussed above).
Hibernate uses the mapping metadata to determine how to load and store objects of the persistent class. The Hibernate mapping file is one choice for providing Hibernate with this metadata.
    <mapping resource="org/me/bar/Customer.hbm.xml"/>


Using the StandardServiceRegistry we create the org.hibernate.boot.MetadataSources which is the start point for telling Hibernate about your domain model. Again, since we defined that in hibernate.cfg.xml so there is not much interesting to see here.
org.hibernate.boot.Metadata represents the complete, partially validated view of the application domain model which the SessionFactory will be based on.
The final step in the bootstrap process is to build the SessionFactory. The SessionFactory is a thread-safe object that is instantiated once to serve the entire application.

Building the ServiceRegistry
Actually we are concerned with building 2 different ServiceRegistries:
org.hibernate.boot.registry.BootstrapServiceRegistry :  is intended to hold services that Hibernate needs at both bootstrap and run time
org.hibernate.boot.registry.StandardServiceRegistry
The second form will create a BootstrapServiceRegistry on the fly with default behavior.
A StandardServiceRegistry is also highly configurable via the StandardServiceRegistryBuilder API.


The SessionFactory acts as a factory for org.hibernate.Session instances, which should be thought of as a corollary to a "unit of work".
 
protected void setUp() throws Exception {
	// A SessionFactory is set up once for an application!
	final StandardServiceRegistry registry = new StandardServiceRegistryBuilder()
			.configure() // configures settings from hibernate.cfg.xml
			.build();
	try {
		sessionFactory = new MetadataSources( registry ).buildMetadata().buildSessionFactory();
	}
	catch (Exception e) {
		// The registry would be destroyed by the SessionFactory, but we had trouble building the SessionFactory
		// so destroy it manually.
		StandardServiceRegistryBuilder.destroy( registry );
	}
}

more details  on confiugration:
==========================
The bootstrapping API is quite flexible, but in most cases it makes the most sense to think of it as a 3 step process:

Build the StandardServiceRegistry
Build the Metadata
Use those 2 things to build the SessionFactory

    StandardServiceRegistry standardRegistry = new StandardServiceRegistryBuilder()
            .configure( "org/hibernate/example/MyCfg.xml" )
            .build();

    Metadata metadata = new MetadataSources( standardRegistry )
            .addAnnotatedClass( MyEntity.class )
            .addAnnotatedClassName( "org.hibernate.example.Customer" )
            .addResource( "org/hibernate/example/Order.hbm.xml" )
            .addResource( "org/hibernate/example/Product.orm.xml" )
            .getMetadataBuilder()
            .applyImplicitNamingStrategy( ImplicitNamingStrategyJpaCompliantImpl.INSTANCE )
            .build();

    SessionFactory sessionFactory = metadata.getSessionFactoryBuilder()
                       .build();


Session session = sessionFactory.openSession();
session.beginTransaction();
session.save( new Event( "Our very first event!", new Date() ) );
session.save( new Event( "A follow up event", new Date() ) );
session.getTransaction().commit();
session.close();

Using Native Hibernate APIs and Annotation Mappings
================================================
Bootstrap a Hibernate SessionFactory
 Use annotations to provide mapping information
 Use the Hibernate native APIs

The contents are identical to The Hibernate configuration file with one important difference…​The <mapping/> element at the very end naming the annotated entity class using the class attribute.
<mapping class="com.mkyong.stock.StockDailyRecord" />

The annotated entity Java class
The entity class in this tutorial is org.hibernate.tutorial.annotations.Event which follows JavaBean conventions. In fact the class itself is identical to the one in The entity Java class, except that annotations are used to provide the metadata, rather than a separate mapping file.

@Entity
@Table( name = "EVENTS" )
public class Event {
    ...
}

The @javax.persistence.Entity annotation is used to mark a class as an entity. It functions the same as the <class/> mapping element discussed in The mapping file. Additionally the @javax.persistence.Table annotation explicitly specifies the table name. Without this specification, the default table name would be EVENT.

Example 8. Identifying the identifier property
@Id
@GeneratedValue(generator="increment")
@GenericGenerator(name="increment", strategy = "increment")
public Long getId() {
    return id;
}
@javax.persistence.Id marks the property which defines the entity’s identifier.

@javax.persistence.GeneratedValue and @org.hibernate.annotations.GenericGenerator work in tandem to indicate that Hibernate should use Hibernate’s increment generation strategy for this entity’s identifier values.

Tutorial Using the Java Persistence API (JPA)
===========================================
 Bootstrap a JPA EntityManagerFactory
 Use annotations to provide mapping information
 Use JPA API calls

persistence.xml
The previous tutorials used the Hibernate-specific hibernate.cfg.xml configuration file. JPA, however, defines a different bootstrap process that uses its own configuration file named persistence.xml. This bootstrapping process is defined by the JPA specification. In Java™ SE environments the persistence provider (Hibernate in this case) is required to locate all JPA configuration files by classpath lookup of the META-INF/persistence.xml resource name.

Example 10. persistence.xml
<persistence xmlns="http://java.sun.com/xml/ns/persistence"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd"
        version="2.0">
  
 <persistence-unit name="org.hibernate.tutorial.jpa" transaction-type="...">
  <provider>...</provider>
  <exclude-unlisted-classes>true/false</exclude-unlisted-classes>
  <properties>
   <property name="javax.persistence.schema-generation.database.action" value="..."/>
   <property name="javax.persistence.jdbc.url" value="..."/>
  </properties>
  <mapping-file>...</mapping-file>
  <class>...</class>
  <class>...</class>
 </persistence-unit>
</persistence>

persistence.xml files should provide a unique name for each "persistence unit". Applications use this name to reference the configuration when obtaining an javax.persistence.EntityManagerFactory reference.

Where:

-->name: A unique name for persistence unit. It is used to create the instance of EntityManagerFactory by using Persistence. create Entity Manager Factory as shown in above code snippet.
-->transaction-type: Possible values are JTA (used in Java EE environment) and RESOURCE_LOCAL. If RESOURCE_LOCAL is specified then the application is responsible to do transaction management manually, typically like this:
    entityManager.getTransaction().begin();
    entityManager.persist(entity);
            ......
    entityManager.getTransaction().commit();
        
-->provider: This specifies the qualified name of the persistence provider's javax.persistence.spi.PersistenceProvider implementation, e.g. if we are using EclipseLink then it would be: org.eclipse.persistence.jpa.PersistenceProvider
-->exclude-unlisted-classes: If this is set to false then entity classes will be discovered by scanning annotations, otherwise, we have to list all entity classes specified explicitly by <class></class> elements.
-->properties: This element can be used to specify both standard and vendor-specific properties. For example, the standard property javax. persistence. schema-generation. database . action specifies the action to be taken by the persistence provider with regard to the database schema automatic generation. The possible values for this property are none/create/drop-and-create/drop. If this property is not specified or is none, no schema generation actions will be taken on the database.
mapping-file: This is to specify one or more object/relational mapping XML files, if we do not want to specify all of them in 'this' persistence.xml file.


Obtaining the javax.persistence.EntityManagerFactory
=============================================
protected void setUp() throws Exception {
	entityManagerFactory = Persistence.createEntityManagerFactory( "org.hibernate.tutorial.jpa" );
}
Notice again that the persistence unit name is org.hibernate.tutorial.jpa, which matches persistence.xml.

Example 12. Saving (persisting) entities
EntityManager entityManager = entityManagerFactory.createEntityManager();
entityManager.getTransaction().begin();
entityManager.persist( new Event( "Our very first event!", new Date() ) );
entityManager.persist( new Event( "A follow up event", new Date() ) );
entityManager.getTransaction().commit();
entityManager.close();

Using Envers
=============
 Annotate an entity as historical
 Configure Envers
 Use the Envers APIs to view and analyze historical data

again, the entity is largely the same as in The annotated entity Java class. The major difference is the addition of the @org.hibernate.envers.Audited annotation, which tells Envers to automatically track changes to this entity.

The code saves some entities, makes a change to one of the entities and then uses the Envers API to pull back the initial revision as well as the updated revision. A revision refers to a historical snapshot of an entity.

Example 14. Using the org.hibernate.envers.AuditReader
public void testBasicUsage() {
    ...
    AuditReader reader = AuditReaderFactory.get( entityManager );
    Event firstRevision = reader.find( Event.class, 2L, 1 );
    ...
    Event secondRevision = reader.find( Event.class, 2L, 2 );
    ...
}
We see that an org.hibernate.envers.AuditReader is obtained from the org.hibernate.envers.AuditReaderFactory which wraps the javax.persistence.EntityManager.

persistenceunit-vs-persistencecontext
================================
EntityManager obtained via @PersistenceContext is called Container Managed EntityManager as container will be responsible for managing "EntityManager". 
EntityManager obtained via @PersistenceUnit / entityManagerFactory.createEntityManager() is managed in the application by the developer. (for e.g. managing lifecycle of EntityManager, releasing the resources acquired by EntityManager, etc.).


JPA - Persistence-Context vs Persistence-Unit. Proper use of EntityManager and EntityManagerFactory
==================================================================================================

An instance of the interface javax. persistence.EntityManager is used to persist, retrieve, update and remove entities to/from the database. Depending on the environment, an EntityManager can be used in following two ways:

1.Container-managed entity manger: In this case, the instance of EntityManager is managed automatically by the container. We typically obtain the instance of EntityManager by injecting it with @PersistenceContext. This is only applicable to Java EE environment
2. Application-managed entity manager: In this case, we have to explicitly obtain and manage the instance(s) of EntityManager. This is applicable to both Java EE or stand-alone/Java SE applications.



As per Spring documentation
===============================
===============================
The Spring JPA support offers three ways of setting up the JPA EntityManagerFactory that will be used by the application to obtain an entity manager.

1. LocalEntityManagerFactoryBean
------------------------------

Only use this option in simple deployment environments such as stand-alone applications and integration tests.

The LocalEntityManagerFactoryBean creates an EntityManagerFactory suitable for simple deployment environments where the application uses only JPA for data access. The factory bean uses the JPA PersistenceProvider autodetection mechanism (according to JPA's Java SE bootstrapping) and, in most cases, requires you to specify only the persistence unit name:

<beans>

   <bean id="myEmf" class="org.springframework.orm.jpa.LocalEntityManagerFactoryBean">
      <property name="persistenceUnitName" value="myPersistenceUnit"/>
   </bean>

</beans>
This form of JPA deployment is the simplest and the most limited. You cannot refer to an existing JDBC DataSource bean definition and no support for global transactions exists. Furthermore, weaving (byte-code transformation) of persistent classes is provider-specific, often requiring a specific JVM agent to specified on startup. This option is sufficient only for stand-alone applications and test environments, for which the JPA specification is designed.

2. Obtaining an EntityManagerFactory from JNDI
--------------------------------------------
[Note]	Note
Use this option when deploying to a Java EE 5 server. Check your server's documentation on how to deploy a custom JPA provider into your server, allowing for a different provider than the server's default.

Obtaining an EntityManagerFactory from JNDI (for example in a Java EE 5 environment), is simply a matter of changing the XML configuration:

<beans>

    <jee:jndi-lookup id="myEmf" jndi-name="persistence/myPersistenceUnit"/>

</beans>
This action assumes standard Java EE 5 bootstrapping: the Java EE server autodetects persistence units (in effect, META-INF/persistence.xml files in application jars) and 
persistence-unit-ref entries in the Java EE deployment descriptor (for example, web.xml) and defines environment naming context locations for those persistence units.

3 LocalContainerEntityManagerFactoryBean
------------------------------------------
[Note]	Note
Use this option for full JPA capabilities in a Spring-based application environment. This includes web containers such as Tomcat as well as stand-alone applications and integration tests with sophisticated persistence requirements.

The LocalContainerEntityManagerFactoryBean gives full control over EntityManagerFactory configuration and is appropriate for environments where fine-grained customization is required. The LocalContainerEntityManagerFactoryBean creates a PersistenceUnitInfo instance based on the persistence.xml file, the supplied dataSourceLookup strategy, and the specified loadTimeWeaver. It is thus possible to work with custom data sources outside of JNDI and to control the weaving process. The following example shows a typical bean definition for a LocalContainerEntityManagerFactoryBean:

<beans>
        
 <bean id="myEmf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
  <property name="dataSource" ref="someDataSource"/>
  <property name="loadTimeWeaver">
    <bean class="org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver"/>
  </property>
 </bean>
 
</beans>
The following example shows a typical persistence.xml file:

<persistence xmlns="http://java.sun.com/xml/ns/persistence" version="1.0">

  <persistence-unit name="myUnit" transaction-type="RESOURCE_LOCAL">
    <mapping-file>META-INF/orm.xml</mapping-file>
    <exclude-unlisted-classes/>
  </persistence-unit>

</persistence>
[Note]	Note
The exclude-unlisted-classes element always indicates that no scanning for annotated entity classes is supposed to occur, in order to support the <exclude-unlisted-classes/> shortcut. This is in line with the JPA specification, which suggests that shortcut, but unfortunately is in conflict with the JPA XSD, which implies false for that shortcut. Consequently, <exclude-unlisted-classes> false </exclude-unlisted-classes/> is not supported. Simply omit the exclude-unlisted-classes element if you want entity class scanning to occur.

Using the LocalContainerEntityManagerFactoryBean is the most powerful JPA setup option, allowing for flexible local configuration within the application. It supports links to an existing JDBC DataSource, supports both local and global transactions, and so on. However, it also imposes requirements on the runtime environment, such as the availability of a weaving-capable class loader if the persistence provider demands byte-code transformation.

This option may conflict with the built-in JPA capabilities of a Java EE 5 server. In a full Java EE 5 environment, consider obtaining your EntityManagerFactory from JNDI. Alternatively, specify a custom persistenceXmlLocation on your LocalContainerEntityManagerFactoryBean definition, for example, META-INF/my-persistence.xml, and only include a descriptor with that name in your application jar files. Because the Java EE 5 server only looks for default META-INF/persistence.xml files, it ignores such custom persistence units and hence avoid conflicts with a Spring-driven JPA setup upfront. (This applies to Resin 3.1, for example.)



4 Dealing with multiple persistence units
----------------------------------------
For applications that rely on multiple persistence units locations, stored in various JARS in the classpath, for example, Spring offers the PersistenceUnitManager to act as a central repository and to avoid the persistence units discovery process, which can be expensive. The default implementation allows multiple locations to be specified that are parsed and later retrieved through the persistence unit name. (By default, the classpath is searched for META-INF/persistence.xml files.)

<bean id="pum" class="org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager">
  <property name="persistenceXmlLocations">
    <list>
     <value>org/springframework/orm/jpa/domain/persistence-multi.xml</value>
     <value>classpath:/my/package/**/custom-persistence.xml</value>
     <value>classpath*:META-INF/persistence.xml</value>
    </list>
  </property>
  <property name="dataSources">
   <map>
    <entry key="localDataSource" value-ref="local-db"/>
    <entry key="remoteDataSource" value-ref="remote-db"/>
   </map>
  </property>
  <!-- if no datasource is specified, use this one -->
  <property name="defaultDataSource" ref="remoteDataSource"/>
</bean>

<bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
  <property name="persistenceUnitManager" ref="pum"/>
  <property name="persistenceUnitName" value="myCustomUnit"/>
</bean>
The default implementation allows customization of the PersistenceUnitInfo instances, before they are fed to the JPA provider, declaratively through its properties, which affect all hosted units, or programmatically, through the PersistenceUnitPostProcessor, which allows persistence unit selection. If no PersistenceUnitManager is specified, one is created and used internally by LocalContainerEntityManagerFactoryBean.


For transactino use JpatransactionManager

<bean id="myTxManager" class="org.springframework.orm.jpa.JpaTransactionManager">
    <property name="entityManagerFactory" ref="myEmf"/>
  </bean>

here myEmf refer above line



Implementing DAOs Based on JPA: EntityManagerFactory and EntityManager
==========================================================================
Although EntityManagerFactory instances are thread-safe, EntityManager instances are not. The injected JPA EntityManager behaves like an EntityManager fetched from an application server’s JNDI environment, as defined by the JPA specification. It delegates all calls to the current transactional EntityManager, if any. Otherwise, it falls back to a newly created EntityManager per operation, in effect making its usage thread-safe.

It is possible to write code against the plain JPA without any Spring dependencies, by using an injected EntityManagerFactory or EntityManager. Spring can understand the @PersistenceUnit and @PersistenceContext annotations both at the field and the method level if a PersistenceAnnotationBeanPostProcessor is enabled. The following example shows a plain JPA DAO implementation that uses the @PersistenceUnit annotation:


public class ProductDaoImpl implements ProductDao {

    private EntityManagerFactory emf;

    @PersistenceUnit
    public void setEntityManagerFactory(EntityManagerFactory emf) {
        this.emf = emf;
    }

    public Collection loadProductsByCategory(String category) {
        try (EntityManager em = this.emf.createEntityManager()) {
            Query query = em.createQuery("from Product as p where p.category = ?1");
            query.setParameter(1, category);
            return query.getResultList();
        }
    }
}


The main problem with such a DAO is that it always creates a new EntityManager through the factory. You can avoid this by requesting a transactional EntityManager (also called a “shared EntityManager” because it is a shared, thread-safe proxy for the actual transactional EntityManager) to be injected instead of the factory. The following example shows how to do so:


public class ProductDaoImpl implements ProductDao {

    @PersistenceContext
    private EntityManager em;

    public Collection loadProductsByCategory(String category) {
        Query query = em.createQuery("from Product as p where p.category = :category");
        query.setParameter("category", category);
        return query.getResultList();
    }
}
The @PersistenceContext annotation has an optional attribute called type, which defaults to PersistenceContextType.TRANSACTION. You can use this default to receive a shared EntityManager proxy. The alternative, PersistenceContextType.EXTENDED, is a completely different affair. This results in a so-called extended EntityManager, which is not thread-safe and, hence, must not be used in a concurrently accessed component, such as a Spring-managed singleton bean. Extended EntityManager instances are only supposed to be used in stateful components that, for example, reside in a session, with the lifecycle of the EntityManager not tied to a current transaction but rather being completely up to the application.



Spring Data Repositories
Let's start with the JpaRepository – which extends PagingAndSortingRepository and, in turn, the CrudRepository.

Each of these defines its own functionality:

CrudRepository provides CRUD functions
PagingAndSortingRepository provides methods to do pagination and sort records
JpaRepository provides JPA related methods such as flushing the persistence context and delete records in a batch


=======+++++++++++++++++++++++=====================


EntityManager Recommendation: LocalContainerEntityManagerFactoryBean
We recommend the following entity manager factory: LocalContainerEntityManagerFactoryBean See: LocalContainerEntityManagerFactoryBean
The most powerful of the three options
Can be used to specify dynamic declarative configs rather than using persistence.xml as we have done so in the template
Can specify/inject a loadTimeWeaver, dataSource, JPA Vendor via Spring
Please See Spring DAO Template provided
@PersistenceUnit vs @PersistenceContext: which to use
	@PersistenceUnit annotation is used in J5SE applications to handle Java Persistence API (JPA) persistence management. You may use a PeristenceUnit in an application inside a container, but it must be managed by the developer instead of the container.
	
	@PersistenceContext annotation is used for Container Managed Persistence (CMP). This relieves the developer of having to worry about connection management.

Recommendation: use @PersistenceContext when using Spring
Spring will do the hard work on your behalf
*
...
/**
* DAO to manage Fund entities.
* 
*/
@Repository("FundDAO")
public class FundDAOImpl extends AbstractJpaDao implements FundDAO {

/**
* EntityManager injected by Spring for persistence unit costshare_pu_02
*
*/
@PersistenceContext(unitName = "costshare_pu_02")
private EntityManager entityManager;

...
}
... 
*
EntityManagerFactory vs EntityManager: 
=============================
EntityManager: whenever using spring avoid managing/using EntityManagerFactory since Spring manages concurreny for you.
The entity manger injected by @PersistenceContext is thread safe.
While EntityManagerFactory instances are thread-safe, EntityManager instances are not. The injected JPA EntityManager behave just like an EntityManager fetched from an application server's JNDI environment, as defined by the JPA specification. It will delegate all calls to the current transactional EntityManager, if any; else, it will fall back to a newly created EntityManager per operation, making it thread-safe.

See Spring Docs: The pros and cons of injecting EntityManagerFactory vs EntityManager are all spelled out.

EntityManager and Transaction Manager:
 The persist, merge, remove, and refresh methods MUST be invoked within a transaction context when an entity manager with a transaction-scoped persistence context is used. If there is no transaction context, the javax.persistence.TransactionRequiredException is thrown.

LocalEntityManagerFactoryBean vs LocalContainerEntityManagerFactoryBean
=====================================================================
The documentation says it all:

LocalContainerEntityManagerFactoryBean -- From the link: FactoryBean that creates a JPA EntityManagerFactory according to JPA's standard container bootstrap contract.
	FactoryBean that creates a JPA EntityManagerFactory according to JPA's standard container bootstrap contract. This is the most powerful way to set up a shared JPA EntityManagerFactory in a Spring application context; the EntityManagerFactory can then be passed to JPA-based DAOs via dependency injection. Note that switching to a JNDI lookup or to a LocalEntityManagerFactoryBean definition is just a matter of configuration!

	As with LocalEntityManagerFactoryBean, configuration settings are usually read in from a META-INF/persistence.xml config file, residing in the class path, according to the general JPA configuration contract. However, this FactoryBean is more flexible in that you can override the location of the persistence.xml file, specify the JDBC DataSources to link to, etc. Furthermore, it allows for pluggable class instrumentation through Spring's LoadTimeWeaver abstraction, instead of being tied to a special VM agent specified on JVM startup.

	Internally, this FactoryBean parses the persistence.xml file itself and creates a corresponding PersistenceUnitInfo object (with further configuration merged in, such as JDBC DataSources and the Spring LoadTimeWeaver), to be passed to the chosen JPA PersistenceProvider. This corresponds to a local JPA container with full support for the standard JPA container contract.

	The exposed EntityManagerFactory object will implement all the interfaces of the underlying native EntityManagerFactory returned by the PersistenceProvider, plus the EntityManagerFactoryInfo interface which exposes additional metadata as assembled by this FactoryBean.

LocalEntityManagerFactoryBean -- From the link: FactoryBean that creates a JPA EntityManagerFactory according to JPA's standard standalone bootstrap contract.
	
		FactoryBean that creates a JPA EntityManagerFactory according to JPA's standard standalone bootstrap contract. This is the simplest way to set up a shared JPA EntityManagerFactory in a Spring application context; the EntityManagerFactory can then be passed to JPA-based DAOs via dependency injection. Note that switching to a JNDI lookup or to a LocalContainerEntityManagerFactoryBean definition is just a matter of configuration!

		Configuration settings are usually read from a META-INF/persistence.xml config file, residing in the class path, according to the JPA standalone bootstrap contract. Additionally, most JPA providers will require a special VM agent (specified on JVM startup) that allows them to instrument application classes. See the Java Persistence API specification and your provider documentation for setup details.

		This EntityManagerFactory bootstrap is appropriate for standalone applications which solely use JPA for data access. If you want to set up your persistence provider for an external DataSource and/or for global transactions which span multiple resources, you will need to either deploy it into a full Java EE 5 application server and access the deployed EntityManagerFactory via JNDI, or use Spring's LocalContainerEntityManagerFactoryBean with appropriate configuration for local setup according to JPA's container contract.

		Note: This FactoryBean has limited configuration power in terms of what configuration it is able to pass to the JPA provider. If you need more flexible configuration, for example passing a Spring-managed JDBC DataSource to the JPA provider, consider using Spring's more powerful LocalContainerEntityManagerFactoryBean instead.

Essentially, the only difference is in how they create the JPA EntityManagerFactory.


persistence-unit-as-resource-local-or-jta
====================================

  Comparing RESOURCE_LOCAL and JTA persistence contexts
With <persistence-unit transaction-type="RESOURCE_LOCAL"> YOU are responsible for EntityManager (PersistenceContext/Cache) creating and tracking...

You must use the EntityManagerFactory to get an EntityManager
The resulting EntityManager instance is a PersistenceContext/Cache
An EntityManagerFactory can be injected via the @PersistenceUnit annotation only (not @PersistenceContext)
You are not allowed to use @PersistenceContext to refer to a unit of type RESOURCE_LOCAL
You must use the EntityTransaction API to begin/commit around every call to your EntityManger
Calling entityManagerFactory.createEntityManager() twice results in two separate EntityManager instances and therefor two separate PersistenceContexts/Caches.
It is almost never a good idea to have more than one instance of an EntityManager in use (don't create a second one unless you've destroyed the first)


With <persistence-unit transaction-type="JTA"> the CONTAINER will do EntityManager (PersistenceContext/Cache) creating and tracking...

You cannot use the EntityManagerFactory to get an EntityManager
You can only get an EntityManager supplied by the container
An EntityManager can be injected via the @PersistenceContext annotation only (not @PersistenceUnit)
You are not allowed to use @PersistenceUnit to refer to a unit of type JTA
The EntityManager given by the container is a reference to the PersistenceContext/Cache associated with a JTA Transaction.
If no JTA transaction is in progress, the EntityManager cannot be used because there is no PersistenceContext/Cache.
Everyone with an EntityManager reference to the same unit in the same transaction will automatically have a reference to the same PersistenceContext/Cache
The PersistenceContext/Cache is flushed and cleared at JTA commit time