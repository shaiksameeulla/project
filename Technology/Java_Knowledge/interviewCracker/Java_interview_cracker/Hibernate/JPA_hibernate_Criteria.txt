Criteria API:
============
Simple Example Using Criteria
-------------------------
Let's start by looking at how to retrieve data using Criteria Queries. We'll look at how to get all the instances of a particular class from the database.

We have an Item class that represents the tuple “ITEM” in the database:

public class Item implements Serializable {

    private Integer itemId;
    private String itemName;
    private String itemDescription;
    private Integer itemPrice;

   // standard setters and getters
}
Let's look at a simple criteria query that will retrieve all the rows of “ITEM” from the database:

Session session = HibernateUtil.getHibernateSession();
CriteriaBuilder cb = session.getCriteriaBuilder();
CriteriaQuery<Item> cr = cb.createQuery(Item.class);
Root<Item> root = cr.from(Item.class);
cr.select(root);

Query<Item> query = session.createQuery(cr);
List<Item> results = query.getResultList();
The above query is a simple demonstration of how to get all the items. Let's see it step by step:


freestar
Create an instance of Session from the SessionFactory object
Create an instance of CriteriaBuilder by calling the getCriteriaBuilder() method
Create an instance of CriteriaQuery by calling the CriteriaBuilder createQuery() method
Create an instance of Query by calling the Session createQuery() method
Call the getResultList() method of the query object, which gives us the results
Now that we've covered the basics, let's move on to some of the features of criteria query.

3.1. Using Expressions
The CriteriaBuilder can be used to restrict query results based on specific conditions, by using CriteriaQuery where() method and providing Expressions created by CriteriaBuilder.

Let's see some examples of commonly used Expressions.

In order to get items having a price of more than 1000:

cr.select(root).where(cb.gt(root.get("itemPrice"), 1000));
Next, getting items having itemPrice less than 1000:


freestar
cr.select(root).where(cb.lt(root.get("itemPrice"), 1000));
Items having itemName contain Chair:

cr.select(root).where(cb.like(root.get("itemName"), "%chair%"));
Records having itemPrice between 100 and 200:

cr.select(root).where(cb.between(root.get("itemPrice"), 100, 200));
Items having itemName in Skate Board, Paint and Glue:

cr.select(root).where(root.get("itemName").in("Skate Board", "Paint", "Glue"));
To check if the given property is null:

cr.select(root).where(cb.isNull(root.get("itemDescription")));
To check if the given property is not null:

cr.select(root).where(cb.isNotNull(root.get("itemDescription")));
We can also use the methods isEmpty() and isNotEmpty() to test if a List within a class is empty or not.

Additionally, we can combine two or more of the above comparisons. The Criteria API allows us to easily chain expressions:

Predicate[] predicates = new Predicate[2];
predicates[0] = cb.isNull(root.get("itemDescription"));
predicates[1] = cb.like(root.get("itemName"), "chair%");
cr.select(root).where(predicates);
To add two expressions with logical operations:

Predicate greaterThanPrice = cb.gt(root.get("itemPrice"), 1000);
Predicate chairItems = cb.like(root.get("itemName"), "Chair%");
Items with the above-defined conditions joined with Logical OR:

cr.select(root).where(cb.or(greaterThanPrice, chairItems));
To get items matching with the above-defined conditions joined with Logical AND:

cr.select(root).where(cb.and(greaterThanPrice, chairItems));
3.2. Sorting
Now that we know the basic usage of Criteria, let's look at the sorting functionalities of Criteria.

In the following example, we order the list in ascending order of the name and then in descending order of the price:

cr.orderBy(
  cb.asc(root.get("itemName")), 
  cb.desc(root.get("itemPrice")));
In the next section, we will have a look at how to do aggregate functions.

3.3. Projections, Aggregates and Grouping Functions
Now let's see the different aggregate functions.

Get row count:

CriteriaQuery<Long> cr = cb.createQuery(Long.class);
Root<Item> root = cr.from(Item.class);
cr.select(cb.count(root));
Query<Long> query = session.createQuery(cr);
List<Long> itemProjected = query.getResultList();
The following is an example of aggregate functions — Aggregate function for Average:


freestar
CriteriaQuery<Double> cr = cb.createQuery(Double.class);
Root<Item> root = cr.from(Item.class);
cr.select(cb.avg(root.get("itemPrice")));
Query<Double> query = session.createQuery(cr);
List avgItemPriceList = query.getResultList();
Other useful aggregate methods are sum(), max(), min(), count(), etc.







Criteria Update& Delete
=====================

JPA 2.1 added a list of nice features to the specification. One of them is the support for bulk update and delete operations in the Criteria API. We will have a look at the new CriteriaUpdate and CriteriaDelete classes in this article.


CriteriaUpdate
The CriteriaUpdate interface can be used to implement bulk update operations. But be careful, these operations are directly mapped to database update operations. Therefore the persistence context is not synchronized with the result and there is no optimistic locking of the involved entities. If you use optimistic locking, you need to update the version column as part of your update statement.

The following code shows a bulk update of the amount of multiple orders.

@Stateless
@LocalBean
public class OrderManagement {
    @PersistenceContext
    private EntityManager em;
 
    ...
 
    public void updateOrder(Double oldAmount, Double newAmount) {
        CriteriaBuilder cb = this.em.getCriteriaBuilder();
 
        // create update
        CriteriaUpdate<Order> update = cb.
        createCriteriaUpdate(Order.class);
 
        // set the root class
        Root e = update.from(Order.class);
 
        // set update and where clause
        update.set("amount", newAmount);
        update.where(cb.greaterThanOrEqualTo(e.get("amount"), oldAmount));
 
        // perform update
        this.em.createQuery(update).executeUpdate();
    }
 
    ...
  
}
As you can see, the implementation is very similar to implementing a CriteriaQuery known from JPA2.0. The main differences are the usage of the CriteriaUpdate interface and the call of the update specific set method.

CriteriaDelete
The usage of the CriteriaDelete interface for bulk delete operations is nearly the same as of the CriteriaUpdate interface. Like the CriteriaUpdate operations, the CriteriaDelete operations are directly mapped to database delete operations. Therefore the persistence context is not synchronized with the result of this operation.

The example of a CriteriaDelete operation looks similar to the usage of CriteriaQuery known from JPA2.0 and the CriteriaUpdate operation described above:

@Stateless
@LocalBean
public class OrderManagement {
    @PersistenceContext
    private EntityManager em;
  
    ...
  
    public void deleteOrder(Double amount) {
        CriteriaBuilder cb = this.em.getCriteriaBuilder();
 
        // create delete
        CriteriaDelete<Order> delete = cb.
         createCriteriaDelete(Order.class);
 
        // set the root class
        Root e = delete.from(Order.class);
 
        // set where clause
        delete.where(cb.lessThanOrEqualTo(e.get("amount"), amount));
 
        // perform update
        this.em.createQuery(delete).executeUpdate();
    }
}