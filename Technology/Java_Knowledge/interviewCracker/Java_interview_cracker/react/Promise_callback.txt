Promise vs callback:
====================

I’m going to explain how we can use Callback Functions, Async-Await, and Promises to make operations asynchronous in JavaScript

Callback Functions
Callback functions can be passed into another function as a parameter and it will be executed after the completion of the first function. Also, callback functions can be named functions of anonymous functions. For example,


setInterval function takes a callback function and a time duration as input parameters. Here anonymous call back function is passed into setInterval function.


In this example, I have passed a reference of MyFunction1 as a parameter to MyFunction2 and made a callback. The most important thing to remember is, passing the function as a parameter won't call your function.

Our code snippet looks fine for now. But what will happen if there are multiple callback functions nested inside each one?


It gets a whole lot messier than this when functions become complex and this is a known issue in callback functions which is known as callback hell. To overcome this issue Promises were introduced.

Promises
Simply, a promise is something like an if-else statement. But there are many characteristics within a promise than that. As I mentioned earlier javascript doesn't wait till an asynchronous code block to be executed completely. This behavior needs to be handled specially in scenarios like making API requests to servers because we don't know the status of the server or the time duration it will take to return the response. With the use of Promises, we can handle such scenarios easily. The promise allows us to hold the execution of a code block until the async request is completed.

Promises have 3 states.

	Pending: Initial state before an operation begins
	Fulfilled: When the specified operation was completed
	Rejected: When the operation did not complete; an error is usually thrown

We can create a promise object by using the new keyword and it has 2 callback functions inside that named resolve and reject. When the executor obtains the result, be it soon or late, doesn’t matter, it should call one of those callbacks:

resolve(value) — If the job finished successfully, with the result value. At this state of the promise is FulFilled.
reject(error) — If an error occurred, the err*or is the error object. At this state of the promise is Rejected.
Let’s create a promise……


To use this promise we can easily chain .then() and .catch() like this,


When we call buyCar() function .then() receives a function with an argument which is the resolve value of our promise. .catch() returns the rejected value of our promise.

If you are going to use promises in API calls, there are npm packages like promise, request-promise, and many more that we can use to make things much easier.

Async - Await
First, let's see what is an async function. Simply an async function is a way that we can write a promise more easily. An async function always returns a promise and if the function returns a value, that value will be resolved by the promise and if the function returns an error, it will be rejected.


As I explained both these functions are equal and resolve “This is a Good Car”. This is the same when a promise is rejected. The async function will throw an error.

We always use the AWAIT keyword inside an async function and the reason for that is, we need to make sure that the promises returned in the async function are synchronized. Await eliminates the use of callbacks in .then() and .catch(). In using async and await, async is prepended when returning a promise, await is prepended when calling a promise.


Create a Promise
To create a promise object, we use the Promise() constructor.

let promise = new Promise(function(resolve, reject){
     //do something
});
The Promise() constructor takes a function as an argument. The function also accepts two functions resolve() and reject().

If the promise returns successfully, the resolve() function is called. And, if an error occurs, the reject() function is called.

Example 1: Program with a Promise
const count = true;

let countValue = new Promise(function (resolve, reject) {
    if (count) {
        resolve("There is a count value.");
    } else {
        reject("There is no count value");
    }
});

console.log(countValue);

You can perform an operation after a promise is resolved using methods then(), catch() and finally().

JavaScript then() method
The then() method is used with the callback when the promise is successfully fulfilled or resolved.

The syntax of then() method is:

promiseObject.then(onFulfilled, onRejected);


// returns a promise

let countValue = new Promise(function (resolve, reject) {
  resolve("Promise resolved");
});

// executes when promise is resolved successfully

countValue
  .then(function successValue(result) {
    console.log(result);
  })

  .then(function successValue1() {
    console.log("You can call multiple functions this way.");
  });
  
 
 Error example:
 -----------------
 // returns a promise
let countValue = new Promise(function (resolve, reject) {
   reject('Promise rejected'); 
});

// executes when promise is resolved successfully
countValue.then(
    function successValue(result) {
        console.log(result);
    },
 )

// executes if there is an error
.catch(
    function errorValue(result) {
        console.log(result);
    }
);


JavaScript finally() method
You can also use the finally() method with promises. The finally() method gets executed when the promise is either resolved successfully or rejected. For example,


Their differences can be summarized in the following points:

JavaScript Promise
The syntax is user-friendly and easy to read.
Error handling is easier to manage.
Example:

api().then(function(result) {
    return api2() ;
}).then(function(result2) {
    return api3();
}).then(function(result3) {
    // do work
}).catch(function(error) {
    //handle any error that may occur before this point 
});
JavaScript Callback
The syntax is difficult to understand.
Error handling may be hard to manage.
Example:

api(function(result){
    api2(function(result2){
        api3(function(result3){
             // do work
            if(error) {
                // do something
            }
            else {
                // do something
            }
        });
    });
});
