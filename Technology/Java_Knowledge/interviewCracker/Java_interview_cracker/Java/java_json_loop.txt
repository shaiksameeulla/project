
@JsonManagedReference & @JsonBackReference

@JsonManagedReference is the forward part of reference – the one that gets serialized normally. @JsonBackReference is the back part of reference – it will be omitted from serialization.
	
	So they really depend on the direction of your relationship

public class User {
    public int id;
    public String name;

   @JsonManagedReference
    public List<Item> userItems; 
} 

public class Item {
    public int id;
    public String itemName;

    @JsonBackReference
    public User owner; 
 }

Also note that we can’t switch around the annotations. The following will work for the serialization:

@JsonBackReference
public List<Item> userItems;

@JsonManagedReference
public User owner;

But when we attempt to deserialize the object, it’ll throw an exception, as @JsonBackReference can’t be used on a collection.

If we want to have the serialized Item object contain a reference to the User, we need to use @JsonIdentityInfo. 

====

 Use @JsonView
We can also use the newer @JsonView annotation to exclude one side of the relationship.

In the following example, we’ll use two JSON Views, Public and Internal, where Internal extends Public:

public class Views {
    public static class Public {}

    public static class Internal extends Public {}
}
Copy
We’ll include all User and Item fields in the Public View except the User field userItems, which will be included in the Internal View:

Here’s our “User” entity:

public class User {
    @JsonView(Views.Public.class)
    public int id;

    @JsonView(Views.Public.class)
    public String name;

    @JsonView(Views.Internal.class)
    public List<Item> userItems;
}
Copy
And here’s our “Item” entity:

public class Item {
    @JsonView(Views.Public.class)
    public int id;

    @JsonView(Views.Public.class)
    public String itemName;

    @JsonView(Views.Public.class)
    public User owner;
}
Copy
When we serialize using the Public view, it works correctly because we excluded userItems from being serialized:

