

Here's a very popular implementation using a static class, which brings the powers of lazy loading and thread safety.

1
public class MySingleton {
2
    private MySingleton() {}
3
    private static class SingletonUisngInner {
4
        private static MySingleton mySingleton = new MySingleton();
5
    }
6
​
7
    public static MySingleton getInstance() {
8
        return SingletonUisngInner.mySingleton;
9
    }
10
}


=====================================
There are mainly three concepts in which we can break the singleton property of a Singleton class in Java. In this post, we will discuss how it can break and how to prevent it.

Here is sample Singleton class and SingletonTest class.

Singleton.Java

1
package demo1;
2
​
3
public final class Singleton {
4
​
5
    private static volatile Singleton instance = null;
6
​
7
    private Singleton() {
8
    }
9
​
10
    public static Singleton getInstance() {
11
        if (instance == null) {
12
            synchronized (Singleton.class) {
13
                if (instance == null) {
14
                    instance = new Singleton();
15
                }
16
            }
17
        }
18
        return instance;
19
    }
20
}


SingletonTest.java

1
  package demo1;
2
​
3
public class SingletonTest {
4
    public static void main(String[] args) {
5
        Singleton object1 = Singleton.getInstance();
6
        Singleton object2 = Singleton.getInstance();
7
        System.out.println("Hashcode of Object 1 - " + object1.hashCode());
8
        System.out.println("Hashcode of Object 2 - " + object2.hashCode());
9
    }
10
} 


Here is output; you can see it has the same hashcode for objectOne and objectTwo:

1
Hashcode of Object 1 - 1836019240
2
Hashcode of Object 2 - 1836019240


Now, we will break this pattern. First, we will use Java reflection.

Reflection
Java Reflection is an API used to examine or modify the behavior of methods, classes, and interfaces at runtime. Using the Reflection API, we can create multiple objects in the Singleton class. Consider the following example:

ReflectionSingleton.java

1
  package demo1;
2
​
3
import java.lang.reflect.Constructor;
4
​
5
public class ReflectionSingleton {
6
    public static void main(String[] args)  {
7
​
8
        Singleton objOne = Singleton.getInstance();
9
        Singleton objTwo = null;
10
        try {
11
            Constructor constructor = Singleton.class.getDeclaredConstructor();
12
            constructor.setAccessible(true);
13
            objTwo = (Singleton) constructor.newInstance();
14
        } catch (Exception ex) {
15
            System.out.println(ex);
16
        }
17
​
18
        System.out.println("Hashcode of Object 1 - "+objOne.hashCode());
19
        System.out.println("Hashcode of Object 2 - "+objTwo.hashCode());
20
​
21
    }
22
}   
23
​


This example shows how reflection can break the singleton pattern with Java reflect. You will get two hash codes, as shown below. It has a break on the singleton pattern.

Prevent Singleton Pattern From Reflection
There are many ways to prevent Singleton pattern from Reflection API, but one of the best solutions is to throw a run-time exception in the constructor if the instance already exists. In this, we can not able to create a second instance.

Deserialization
In serialization, we can save the object of a byte stream into a file or send over a network. Suppose if you serialize the Singleton class, and then again de-serialize that object, it will create a new instance, hence deserialization will break the Singleton pattern.

The below code is used to illustrate how the Singleton pattern breaks with deserialization.

Implements Serializable interface for Singleton Class.

DeserializationSingleton.Java

1
package demo1;
2
​
3
import java.io.*;
4
​
5
public class DeserializationSingleton {
6
​
7
    public static void main(String[] args) throws Exception {
8
​
9
        Singleton instanceOne = Singleton.getInstance();
10
        ObjectOutput out = new ObjectOutputStream(new FileOutputStream("file.text"));
11
        out.writeObject(instanceOne);
12
        out.close();
13
​
14
        ObjectInput in = new ObjectInputStream(new FileInputStream("file.text"));
15
        Singleton instanceTwo = (Singleton) in.readObject();
16
        in.close();
17
​
18
        System.out.println("hashCode of instance 1 is - " + instanceOne.hashCode());
19
        System.out.println("hashCode of instance 2 is - " + instanceTwo.hashCode());
20
    }
21
​
22
}


The output is below, and you can see two hashcodes.

1
hashCode of instance 1 is - 2125039532
2
hashCode of instance 2 is - 381259350


Prevent Singleton Pattern From Deserialization
To overcome this issue, we need to override readResolve() method in the Singleton class and return the same Singleton instance. Update Singleton.java, with below method.

1
   protected Object readResolve() { 
2
           return instance; 
3
     }  


Now, run the above DeserializationDemo class and see the output.

1
hashCode of instance 1 is - 2125039532
2
hashCode of instance 2 is - 2125039532


Cloning
Using the "clone" method, we can create a copy of the original object; it's the same thing if we applied clone in the singleton pattern. It will create two instances: one original and another one cloned object. In this case, we will break the Singleton principle, as shown in the below code.

Implement the " Cloneable" interface and override the clone method in the above Singleton class.

Singleton.java

1
    @Override
2
    protected Object clone() throws CloneNotSupportedException  {
3
        return super.clone();
4
    }


Then, test with cloning for breaking the singleton.

CloningSingleton.java

1
public class CloningSingleton {
2
    public static void main(String[] args) throws CloneNotSupportedException, Exception {
3
        Singleton instanceOne = Singleton.getInstance();
4
        Singleton instanceTwo = (Singleton) instanceOne.clone();
5
        System.out.println("hashCode of instance 1 - " + instanceOne.hashCode());
6
        System.out.println("hashCode of instance 2 - " + instanceTwo.hashCode());
7
    }
8
​
9
}


Here is the output:

1
hashCode of instance 1 - 1836019240
2
hashCode of instance 2 - 325040804


If we see the above output, two instances have different hashcodes. This means these instances are not the same.

Prevent Singleton Pattern From Cloning
In the above code, it breaks the Singleton principle, i. e created two instances. To overcome the above issue, we need to implement/override the clone() method and throw an exception CloneNotSupportedException from the clone method. If anyone tries to create a clone object of Singleton, it will throw an exception, as shown in the below code.

1
    @Override
2
    protected Object clone() throws CloneNotSupportedException  {
3
        throw new CloneNotSupportedException();
4
    }


Now, we can run the CloningSingleton class; it will throw CloneNotSupportedException while creating a clone object of the Singleton object.