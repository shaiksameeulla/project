Java 11 new features and enhancements
======================================

Java 11 is the first LTS (Long Term Support) feature release of Java programming language after Java 8. 
It followed the Java release cadence introduced Java 10 onwards and it was released on Sept 2018, just six months after Java 10 release.
Java 9 and Java 10 are non-LTS release. Java 11 release is a LTS release.



New Features
Following are the major new features which are introduced in Java 11.

JEP 321 − HTTP Client API standardized.
JEP 330 − Launch Single-File Source-Code Programs without compilation
JEP 323 − Local-Variable Syntax for Lambda Parameters
JEP 181 − Nest-Based Access Control
JEP 331 − Low-Overhead Heap Profiling
JEP 318 − Epsilon, A No-Op Garbage Collector
JEP 333 − ZGC A Scalable Low-Latency Garbage Collector
Collection API Updates − New Collection.toArray(IntFunction) Default Method.
String API Updates − New methods added like repeat(), isBlank(), strip() and lines().
Files API Updates − New methods added like readString(), and writeString().
Optional Updates − New method added, isEmpty().



1. HTTP Client API
 ---------------
Java had HttpURLConnection class for long time for HTTP communication. But over the time, requirements have gone complex and more demanding in applications. Before Java 11, developers had to resort to feature-rich libraries like Apache HttpComponents or OkHttp etc.

We saw Java 9 release to include an HttpClient implementation as an experimental feature. It has grown over time and now a final feature of Java 11. Now the Java applications can make HTTP communications without the need to any external dependency.

How to use HttpClient
A typical HTTP interaction with the java.net.http module looks like-

	Create an instance of HttpClient and configure it as needed.
	Create an instance of HttpRequest and populate the information.
	Pass the request to the client, perform the request, and retrieve an instance of HttpResponse.
	Process the information contained in the HttpResponse.
HTTP API can handle synchronous and asynchronous communication. Let’s see a quick example.


. Synchronous request example
Notice how the http client API uses builder pattern for creating complex objects.

import java.io.IOException;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;
 
HttpClient httpClient = HttpClient.newBuilder()
                .connectTimeout(Duration.ofSeconds(10))
                .build();                                  
 
try
{
    String urlEndpoint = "https://postman-echo.com/get";
    URI uri = URI.create(urlEndpoint + "?foo1=bar1&foo2=bar2");
    HttpRequest request = HttpRequest.newBuilder()
                        .uri(uri)
                        .build();                              
    HttpResponse<String> response = httpClient.send(request,
                          HttpResponse.BodyHandlers.ofString()); 
} catch (IOException | InterruptedException e) {
    throw new RuntimeException(e);
}
 
System.out.println("Status code: " + response.statusCode());                            
System.out.println("Headers: " + response.headers().allValues("content-type"));               
System.out.println("Body: " + response.body()); 

1.2. Asynchronous request example
	
	Asynchronous communication is useful if we don’t want to wait for the response. We provide callback handler, which gets executed when response is available.

Notice the use of sendAsync() method to send asynchronous request.

import java.io.IOException;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Stream;
import static java.util.stream.Collectors.toList;
 
final List<URI> uris = Stream.of(
                "https://www.google.com/",
                "https://www.github.com/",
                "https://www.yahoo.com/"
                ).map(URI::create).collect(toList());      
 
HttpClient httpClient = HttpClient.newBuilder()
                .connectTimeout(Duration.ofSeconds(10))
                .followRedirects(HttpClient.Redirect.ALWAYS)
                .build();
 
CompletableFuture[] futures = uris.stream()
                  .map(uri -> verifyUri(httpClient, uri))
                  .toArray(CompletableFuture[]::new);     
 
CompletableFuture.allOf(futures).join();           
 
private CompletableFuture<Void> verifyUri(HttpClient httpClient, 
                                          URI uri) 
{
    HttpRequest request = HttpRequest.newBuilder()
                        .timeout(Duration.ofSeconds(5))
                        .uri(uri)
                        .build();
 
    return httpClient.sendAsync(request,HttpResponse.BodyHandlers.ofString())
                  .thenApply(HttpResponse::statusCode)
                  .thenApply(statusCode -> statusCode == 200)
                  .exceptionally(ex -> false)
                  .thenAccept(valid -> 
                  {
                      if (valid) {
                          System.out.println("[SUCCESS] Verified " + uri);
                      } else {
                          System.out.println("[FAILURE] Could not " + "verify " + uri);
                      }
                  });                                    
}

Local Variable Syntax for Lambda Parameters 
==============================================
One of the key features introduced in Java 10 was local variable type inference. It allowed the use of var as the type of the local variable instead of the actual type. The compiler inferred the type based on the value assigned to the variable.

However, we could not use this feature with lambda parameters. For example, consider the following lambda. Here we explicitly specify the types of the parameters:

(String s1, String s2) -> s1 + s2
We could skip the parameter types and rewrite the lambda as:

(s1, s2) -> s1 + s2
Even Java 8 supported this. The logical extension to this in Java 10 would be:

(var s1, var s2) -> s1 + s2
However, Java 10 did not support this.

Java 11 addresses this by supporting the above syntax. This makes the usage of var uniform in both local variables and lambda parameters.


2. Launch Single-File Programs Without Compilation
Traditionally, for every program that we’d like to execute, we need to first compile it. It seems unnecessarily lengthy process for small programs for testing purposes.

Java 11 changes it and now we can execute Java source code contained in a single file without the need to compile it first.

HelloWorld.java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello World!");
    }
}
To execute above class, run it directly with java command.

Console
$ java HelloWorld.java
 
Hello World!
Note that the program cannot use any external dependencies other than the java.base module. And program can be only single-file program.

3. String API Changes
--------------------
3.1. String.repeat(Integer)
This method simply repeats a string n times. It returns a string whose value is the concatenation of given string repeated N times.

If this string is empty or count is zero then the empty string is returned.

HelloWorld.java
public class HelloWorld 
{
    public static void main(String[] args) 
    {
      String str = "1".repeat(5);
 
        System.out.println(str);  //11111
    }
}
3.2. String.isBlank()
This method indicates whether a string is empty or contains only white-spaces. Previously, we have been using it from Apache’s StringUtils.java.

HelloWorld.java
public class HelloWorld 
{
    public static void main(String[] args) 
    {
      "1".isBlank();  //false
 
        "".isBlank(); //true
 
        "    ".isBlank(); //true
    }
}
3.3. String.strip()
This method takes care of removing leading and trailing white-spaces. We can be even more specific by removing just the leading characters by using String.stripLeading() or just the trailing characters by using String.stripTrailing().

HelloWorld.java
public class HelloWorld 
{
    public static void main(String[] args) 
    {
      "   hi  ".strip();  //"hi"
 
       "   hi  ".stripLeading();  //"hi   "
 
       "   hi  ".stripTrailing(); //"   hi"
    }
}
3.4. String.lines()
This method helps in processing multi-line texts as a Stream.

HelloWorld.java
public class HelloWorld 
{
    public static void main(String[] args) 
    {
      String testString = "hello\nworld\nis\nexecuted";
 
      List<String> lines = new ArrayList<>();
 
      testString.lines().forEach(line -> lines.add(line));
 
      assertEquals(List.of("hello", "world", "is", "executed"), lines);
    }
}
4. Collection.toArray(IntFunction)
------------------------------
Before Java 11, converting a collection to array was not straightforward. Java 11 makes the conversion more convenient.

HelloWorld.java
public class HelloWorld 
{
    public static void main(String[] args) 
    {
      List<String> names = new ArrayList<>();
      names.add("alex");
      names.add("brian");
      names.add("charles");
 
      String[] namesArr1 = names.toArray(new String[names.size()]);   //Before Java 11
 
      String[] namesArr2 = names.toArray(String[]::new);          //Since Java 11
    }
}
5. Files.readString() and Files.writeString()
Using these overloaded methods, Java 11 aims to reduce a lot of boilerplate code which makes much easier to read and write files.

HelloWorld.java
public class HelloWorld 
{
    public static void main(String[] args) 
    {
      //Read file as string
      URI txtFileUri = getClass().getClassLoader().getResource("helloworld.txt").toURI();
 
      String content = Files.readString(Path.of(txtFileUri),Charset.defaultCharset());
 
      //Write string to file
      Path tmpFilePath = Path.of(File.createTempFile("tempFile", ".tmp").toURI());
 
      Path returnedFilePath = Files.writeString(tmpFilePath,"Hello World!", 
                    Charset.defaultCharset(), StandardOpenOption.WRITE);
    }
}
6. Optional.isEmpty()
Optional is a container object which may or may not contain a non-null value. If no value is present, the object is considered empty.

Previously existing method isPresent() returns true if a value is present, otherwise false. Sometimes, it forces us to write negative conditions which are not readable.

isEmpty() method is reverse of isPresent() method and returns false if a value is present, otherwise true.

So we do not to write negative conditions in any case. Use any of these two methods when appropriate.

HelloWorld.java
public class HelloWorld 
{
    public static void main(String[] args) 
    {
      String currentTime = null;
 
      assertTrue(!Optional.ofNullable(currentTime).isPresent());  //It's negative condition
      assertTrue(Optional.ofNullable(currentTime).isEmpty());   //Write it like this
 
      currentTime = "12:00 PM";
 
      assertFalse(!Optional.ofNullable(currentTime).isPresent()); //It's negative condition
      assertFalse(Optional.ofNullable(currentTime).isEmpty());  //Write it like this
    }
}