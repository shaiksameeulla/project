Before that, you should know about Spring’s @Conditional feature, on which all Spring Boot’s AutoConfiguration magic depends.

Exploring the Power of @Conditional 
While developing Spring based applications we may come across a need to register beans conditionally.

For example, you may want to register a DataSource bean pointing to the dev database while running application locally and point to a different production database while running in production. 

You can externalize the database connection parameters into the properties file and use the file appropriate for the environment, but you need to change the configuration whenever you need to point to a different environment and build the application.

To address this problem, Spring 3.1 introduced the concept of Profiles. You can register multiple beans of the same type and associate them with one or more profiles. When you run the application you can activate the desired profiles and beans associated with the activated profiles, and only those profiles will be registered.

1@Configuration
2public class AppConfig
3{
4 @Bean
5 @Profile("DEV")
6 public DataSource devDataSource() {
7 ...
8 }
9
​
10@Bean
11 @Profile("PROD")
12 public DataSource prodDataSource() {
13
 ...
14 }
15}
Then you can specify the active profile using System Property -Dspring.profiles.active=DEV.

This approach works for simple cases like enable or disable bean registrations based on activated profiles. But if you want to register beans based on some conditional logic then the profiles approach itself is not sufficient.

To provide more flexibility for registering Spring beans conditionally, Spring 4 introduced the concept of @Conditional. By using the @Conditional approach you can register a bean conditionally based on any arbitrary condition.

For example, you may want to register a bean when:

A specific class is present in classpath
A Spring bean of certain type doesn’t already registered in ApplicationContext
A specific file exists on a location
A specific property value is configured in a configuration file
A specific system property is present/absent
These are just a few examples only and you can have any condition you want.

Let us take a look at how Spring’s @Conditional works.

Suppose we have a UserDAO interface with methods to get data from a data store. We have two implements of UserDAO interface namely JdbcUserDAO which talks to MySQL database and MongoUserDAO which talks to MongoDB.

We may want to enable only one interface of JdbcUserDAO and MongoUserDAO based on a System Property, say dbType.

If the application is started using java -jar myapp.jar -DdbType=MySQL, then we want to enable JdbcUserDAO. Otherwise, if the application is started using java -jar myapp.jar -DdbType=MONGO, we want to enable MongoUserDAO.

Suppose we have a UserDAO bean and a JdbcUserDAO bean. The MongoUserDAO implementation is as follows:

1public interface UserDAO
2{
3 List<String> getAllUserNames();
4}
5​
6public class JdbcUserDAO implements UserDAO
7{
8 @Override
9 public List<String> getAllUserNames()
10 {
11 System.out.println("**** Getting usernames from RDBMS *****");
12 return Arrays.asList("Siva","Prasad","Reddy");
13 }
14}
15
​
16public class MongoUserDAO implements UserDAO
17{
18 @Override
19 public List<String> getAllUserNames()
20 {
21 System.out.println("**** Getting usernames from MongoDB *****");
22 return Arrays.asList("Bond","James","Bond");
23 }
24
}
We can implement the Condition MySQLDatabaseTypeCondition to check whether the System Property dbType is "MYSQL" as follows:

1public class MySQLDatabaseTypeCondition implements Condition
2{
3 @Override
4 public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata metadata)
5 {
6 String enabledDBType = System.getProperty("dbType");
7 return (enabledDBType != null && enabledDBType.equalsIgnoreCase("MYSQL"));
8 }
9}
We can implement the Condition MongoDBDatabaseTypeCondition to check whether the System Property dbType is "MONGODB" as follows:

1public class MongoDBDatabaseTypeCondition implements Condition
2{
3 @Override
4 public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata metadata)
5 {
6 String enabledDBType = System.getProperty("dbType");
7 return (enabledDBType != null && enabledDBType.equalsIgnoreCase("MONGODB"));
8 }
9}
Now we can configure both JdbcUserDAO and MongoUserDAO beans conditionally using @Conditional as follows:

1@Configuration
2public class AppConfig
3{
4 @Bean
5 @Conditional(MySQLDatabaseTypeCondition.class)
6 public UserDAO jdbcUserDAO(){
7 return new JdbcUserDAO();
8 }
9​10@Bean
11 @Conditional(MongoDBDatabaseTypeCondition.class)
12 public UserDAO mongoUserDAO(){
13 return new MongoUserDAO();
14 }
15}
If we run the application like java -jar myapp.jar -DdbType=MYSQL then only the JdbcUserDAO bean will be registered.But if you set the System property like -DdbType=MONGODB then only the MongoUserDAO bean will be registered.

Now that we have seen how to conditionally register a bean based on System Property.

Suppose we want to register MongoUserDAO bean only when MongoDB java driver class "com.mongodb.Server" is available on classpath, if not we want to register JdbcUserDAO bean.

To accomplish that we can create Conditions to check the presence or absence of MongoDB driver class "com.mongodb.Server" as follows:

1
public class MongoDriverPresentsCondition implements Condition
2
{
3
 @Override
4
 public boolean matches(ConditionContext conditionContext,AnnotatedTypeMetadata metadata)
5
 {
6
 try {
7
 Class.forName("com.mongodb.Server");
8
 return true;
9
 } catch (ClassNotFoundException e) {
10
 return false;
11
 }
12
 }
13
}
14
​
15
public class MongoDriverNotPresentsCondition implements Condition
16
{
17
 @Override
18
 public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata metadata)
19
 {
20
 try {
21
 Class.forName("com.mongodb.Server");
22
 return false;
23
 } catch (ClassNotFoundException e) {
24
 return true;
25
 }
26
 }
27
}
We just have seen how to register beans conditionally based on the presence or absence of a class in classpath.

What if we want to register the MongoUserDAO bean only if no other Spring bean of the type UserDAO is already registered.

We can create a Condition to check if there is any existing bean of a certain type as follows:

1
public class UserDAOBeanNotPresentsCondition implements Condition
2
{
3
 @Override
4
 public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata metadata)
5
 {
6
 UserDAO userDAO = conditionContext.getBeanFactory().getBean(UserDAO.class);
7
 return (userDAO == null);
8
 }
9
}
What if we want to register MongoUserDAO bean only if property app.dbType=MONGO is set in properties placeholder configuration file?

We can implement that Condition as follows:

1
public class MongoDbTypePropertyCondition implements Condition
2
{
3
 @Override
4
 public boolean matches(ConditionContext conditionContext,
5
 AnnotatedTypeMetadata metadata)
6
 {
7
 String dbType = conditionContext.getEnvironment()
8
 .getProperty("app.dbType");
9
 return "MONGO".equalsIgnoreCase(dbType);
10
 }
11
}
We have just seen how to implement various types of Conditions.But there is even more elegant way to implement Conditions using Annotations. Instead of creating a Condition implementation for both MYSQL and MongoDB, we can create aDatabaseType annotation as follows:

1
@Target({ ElementType.TYPE, ElementType.METHOD })
2
@Retention(RetentionPolicy.RUNTIME)
3
@Conditional(DatabaseTypeCondition.class)
4
public @interface DatabaseType
5
{
6
 String value();
7
}
Then we can implement DatabaseTypeCondition to use the DatabaseType value to determine whether to enable or disable bean registration as follows:

1
public class DatabaseTypeCondition implements Condition
2
{
3
 @Override
4
 public boolean matches(ConditionContext conditionContext,
5
 AnnotatedTypeMetadata metadata)
6
 {
7
 Map<String, Object> attributes = metadata.getAnnotationAttributes(DatabaseType.class.getName());
8
 String type = (String) attributes.get("value");
9
 String enabledDBType = System.getProperty("dbType","MYSQL");
10
 return (enabledDBType != null && type != null && enabledDBType.equalsIgnoreCase(type));
11
 }
12
}
Now we can use the @DatabaseType annotation on our bean definitions as follows:

1
@Configuration
2
@ComponentScan
3
public class AppConfig
4
{
5
 @DatabaseType("MYSQL")
6
 public UserDAO jdbcUserDAO(){
7
 return new JdbcUserDAO();
8
 }
9
​
10
 @Bean
11
 @DatabaseType("MONGO")
12
 public UserDAO mongoUserDAO(){
13
 return new MongoUserDAO();
14
 }
15
}
Here we are getting the metadata from DatabaseType annotation and checking against the System Property dbType value to determine whether to enable or disable the bean registration.

We have seen good number of examples to understand how we can register beans conditionally using @Conditional annotation.

Spring Boot extensively uses @Conditional feature to register beans conditionally based on various criteria.

You can find various Condition implementations that SpringBoot uses in org.springframework.boot.autoconfigure package of spring-boot-autoconfigure-{version}.jar.

Now that we've come to know about how Spring Boot uses the @Conditional feature to conditionally check whether to register a bean or not, but what exactly triggers the auto-configuration mechanism?

This is what we are going to look at in the next section.

Spring Boot AutoConfiguration 
The key to the Spring Boot’s auto-configuration magic is @EnableAutoConfiguration annotation. Typically we annotate our Application entry point class with either @SpringBootApplication or if we want to customize the defaults we can use the following annotations:

1
@Configuration
2
@EnableAutoConfiguration
3
@ComponentScan
4
public class Application
5
{
6
​
7
}
The @EnableAutoConfiguration annotation enables the auto-configuration of Spring ApplicationContext by scanning the classpath components and registers the beans that are matching various Conditions.

SpringBoot provides various AutoConfiguration classes in spring-boot-autoconfigure-{version}.jar, which are responsible for registering various components.

Typically AutoConfiguration classes are annotated with @Configuration to mark it as a Spring configuration class and annotated with @EnableConfigurationProperties to bind the customization properties and one or more Conditional bean registration methods.

For example, consider the org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration class.

1
@Configuration
2
@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })
3
@EnableConfigurationProperties(DataSourceProperties.class)
4
@Import({ Registrar.class, DataSourcePoolMetadataProvidersConfiguration.class })
5
public class DataSourceAutoConfiguration 
6
{
7
 ...
8
 ...
9
 @Conditional(DataSourceAutoConfiguration.EmbeddedDataSourceCondition.class)
10
 @ConditionalOnMissingBean({ DataSource.class, XADataSource.class })
11
 @Import(EmbeddedDataSourceConfiguration.class)
12
 protected static class EmbeddedConfiguration {
13
​
14
 }
15
​
16
 @Configuration
17
 @ConditionalOnMissingBean(DataSourceInitializer.class)
18
 protected static class DataSourceInitializerConfiguration {
19
 @Bean
20
 public DataSourceInitializer dataSourceInitializer() {
21
 return new DataSourceInitializer();
22
 }
23
 }
24
​
25
 @Conditional(DataSourceAutoConfiguration.NonEmbeddedDataSourceCondition.class)
26
 @ConditionalOnMissingBean({ DataSource.class, XADataSource.class })
27
 protected static class NonEmbeddedConfiguration {
28
 @Autowired
29
 private DataSourceProperties properties;
30
​
31
 @Bean
32
 @ConfigurationProperties(prefix = DataSourceProperties.PREFIX)
33
 public DataSource dataSource() {
34
 DataSourceBuilder factory = DataSourceBuilder
35
 .create(this.properties.getClassLoader())
36
 .driverClassName(this.properties.getDriverClassName())
37
 .url(this.properties.getUrl()).username(this.properties.getUsername())
38
 .password(this.properties.getPassword());
39
 if (this.properties.getType() != null) {
40
 factory.type(this.properties.getType());
41
 }
42
 return factory.build();
43
 }
44
 }
45
 ...
46
 ...
47
 @Configuration
48
 @ConditionalOnProperty(prefix = "spring.datasource", name = "jmx-enabled")
49
 @ConditionalOnClass(name = "org.apache.tomcat.jdbc.pool.DataSourceProxy")
50
 @Conditional(DataSourceAutoConfiguration.DataSourceAvailableCondition.class)
51
 @ConditionalOnMissingBean(name = "dataSourceMBean")
52
 protected static class TomcatDataSourceJmxConfiguration {
53
 @Bean
54
 public Object dataSourceMBean(DataSource dataSource) {
55
 ....
56
 ....
57
 }
58
 }
59
 ...
60
 ...
61
}
Here, DataSourceAutoConfiguration is annotated with @ConditionalOnClass({ DataSource.class,EmbeddedDatabaseType.class }) which means that the AutoConfiguration of beans within DataSourceAutoConfiguration will be considered only if the DataSource.class and EmbeddedDatabaseType.class classes are available on classpath.

The class is also annotated with @EnableConfigurationProperties(DataSourceProperties.class) which enables binding the properties in application.properties to the properties of DataSourceProperties class automatically.

1
@ConfigurationProperties(prefix = DataSourceProperties.PREFIX)
2
public class DataSourceProperties implements BeanClassLoaderAware, EnvironmentAware, InitializingBean {
3
​
4
 public static final String PREFIX = "spring.datasource";
5
 ...
6
 ...
7
 private String driverClassName;
8
 private String url;
9
 private String username;
10
 private String password;
11
 ...
12
 //setters and getters
13
}
With this configuration all the properties that starts with spring.datasource.* will be automatically binds to DataSourceProperties object.

1
spring.datasource.url=jdbc:mysql://localhost:3306/test
2
spring.datasource.username=root
3
spring.datasource.password=secret
4
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
You can also see some inner classes and bean definition methods that are annotated with SpringBoot’s Conditional annotations such as @ConditionalOnMissingBean, @ConditionalOnClass and @ConditionalOnProperty etc.

These bean definitions will be registered in ApplicationContext only if those conditions are matched.

You can also explore many other AutoConfiguration classes in spring-boot-autoconfigure-{version}.jar such as:

org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration 
org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration 
org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration 
org.springframework.boot.autoconfigure.jackson.JacksonAutoConfigurationetc etc. 
I hope now you have an understanding of how Spring Boot auto-configuration works by using various AutoConfiration classes along with @Conditional features.