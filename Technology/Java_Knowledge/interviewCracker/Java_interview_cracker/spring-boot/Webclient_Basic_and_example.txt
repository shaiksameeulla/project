Webclient:

Spring WebClient is a non-blocking and reactive web client to perform HTTP requests. It is also the replacement for the classic RestTemplate. It is a part of spring-webflux library and also offers support for both synchronous and asynchronous operations. The DefaultWebClient class implements this WebClient interface.


<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-webflux</artifactId>
</dependency>


example

public String getAllProductsByWebClientGet() {
		WebClient webClient = WebClient.create("https://dummyjson.com/products");
		Mono<ResponseEntity<String>> entityMono = webClient.get()
			   .accept(MediaType.APPLICATION_JSON)
			     .retrieve()
			     .toEntity(String.class);
			 
		
		return entityMono.block().getBody();
	
		
	}
	public String getAllProductsByWebClientGetById(String productId) {
		//
		WebClient webClient = WebClient.create("https://dummyjson.com/products/{productId}");
		
		Mono<ResponseEntity<String>> entityMono = webClient.get().uri(uribuilder->uribuilder.build(productId))
				.accept(MediaType.APPLICATION_JSON)
			     .retrieve()
			     .toEntity(String.class);
			 
		
		return entityMono.block().getBody();
	
		
	}
	public String getAllProductsByWebClientGetMapById(String productId) {
		//
		WebClient webClient = WebClient.create("https://dummyjson.com/products/{productId}");
		Map hashmap= new HashMap<>();
		hashmap.put("productId", productId);
		Mono<ResponseEntity<String>> entityMono = webClient.get().uri(uribuilder->uribuilder.build(hashmap))
				.accept(MediaType.APPLICATION_JSON)
			     .retrieve()
			     .toEntity(String.class);
			 
		
		return entityMono.block().getBody();
	
		
	}
	
	
	webClient.get()
  .uri(uriBuilder - > uriBuilder
    .path("/products/")
    .queryParam("name", "AndroidPhone")
    .queryParam("color", "black")
    .queryParam("deliveryDate", "13/04/2019")
    .build())
  .retrieve()
  .bodyToMono(String.class)
  .onErrorResume(e -> Mono.empty())
  .block();
  
  verifyCalledUrl("/products/?name=AndroidPhone&color=black&deliveryDate=13/04/2019");
  
  
  Here we added three query parameters and assigned actual values immediately. Conversely, it’s also possible to leave placeholders instead of exact values:

webClient.get()
  .uri(uriBuilder - > uriBuilder
    .path("/products/")
    .queryParam("name", "{title}")
    .queryParam("color", "{authorId}")
    .queryParam("deliveryDate", "{date}")
    .build("AndroidPhone", "black", "13/04/2019"))
  .retrieve()
  .bodyToMono(String.class)
  .block();

verifyCalledUrl("/products/?name=AndroidPhone&color=black&deliveryDate=13%2F04%2F2019");

This might be especially helpful when passing a builder object further in a chain.

Note that there’s one important difference between the two code snippets above. With attention to the expected URIs, we can see that they’re encoded differently. Particularly, the slash character ( / ) was escaped in the last example.