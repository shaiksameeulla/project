<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:tx="http://www.springframework.org/schema/tx"

	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
	    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd
	http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd">


	<!-- <bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
    	<property name="locations" >
            <list>
                 <value>WEB-INF/jdbc.properties</value>
                 <value>classpath:email.properties</value>
            </list>
        </property>
	</bean> -->
	
	<!-- The will be the encryptor used for decrypting configuration values.  START -->
 <!--                                                                      -->
 <bean id="configurationEncryptor"
     class="org.jasypt.encryption.pbe.StandardPBEStringEncryptor">
   <property name="password" value="UDAAN" />
 </bean>
	<bean id="propertyConfigurer"
     class="org.jasypt.spring31.properties.EncryptablePropertyPlaceholderConfigurer">
   <constructor-arg ref="configurationEncryptor" />
   <property name="locations">
     <list>
                 <value>WEB-INF/jdbc.properties</value>
                 <value>classpath:email.properties</value>
            </list>
   </property>
   <!-- The will be the encryptor used for decrypting configuration values.  END -->
 </bean>


	<bean id="UDAANDataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
		<!-- Connection properties -->
		<property name="driverClass" value="${jdbc.mysql.driverClassName}" />
		<property name="jdbcUrl" value="${udaan.jdbc.url}" />
		<property name="user" value="${jdbc.retail.user}" />
		<property name="password" value="${jdbc.retail.password}" />

		<!-- Basic Pool Configuration -->
		<property name="initialPoolSize" value="${initialPoolSize}" />
		<property name="minPoolSize" value="${minPoolSize}" />
		<property name="maxPoolSize" value="${maxPoolSize}" /> <!-- No of connecton -->
		<property name="maxIdleTime" value="${maxIdleTime}" />
		<property name="acquireIncrement" value="${acquireIncrement}" />

		<!-- Configuring Connection Testing -->

		<property name="idleConnectionTestPeriod" value="${idleConnectionTestPeriod}" />
		<property name="maxIdleTimeExcessConnections" value="${maxIdleTimeExcessConnections}" />
		<property name="maxConnectionAge" value="${maxConnectionAge}" />
		<property name="preferredTestQuery" value="${preferredTestQuery}" />

		<!-- Configuring Statement Pooling -->
		<property name="maxStatements" value="${maxStatements}" /> <!-- 0 means: statement caching is turned off. -->
		<property name="numHelperThreads" value="${numHelperThreads}" />

		<!-- Configuring Recovery From Database Outages -->
		<property name="acquireRetryAttempts" value="${acquireRetryAttempts}" />
		<property name="AcquireRetryDelay" value="${AcquireRetryDelay}" />
		<property name="BreakAfterAcquireFailure" value="${BreakAfterAcquireFailure}" />

		<!--Other DataSource Configuration <property name="checkoutTimeout" value="${checkoutTimeout}" 
			/> -->

		<!--Configuring to Debug and Workaround Broken Client Applications, Don't 
			use these in production' -->
		<property name="unreturnedConnectionTimeout" value="${unreturnedConnectionTimeout}" />
		<property name="debugUnreturnedConnectionStackTraces" value="${debugUnreturnedConnectionStackTraces}" />

	</bean>

	<!-- Session Factory -->
	<bean id="hibernateSessionFactory"
		class="org.springframework.orm.hibernate3.LocalSessionFactoryBean">

		<property name="dataSource" ref="UDAANDataSource" />
		<!--
			/** 
			 * Extension of Hibernate's DefaultMergeEventListener, transferring the ids
			 * of newly saved objects to the corresponding original objects (that are part
			 * of the detached object graph passed into the <code>merge</code> method).
			 *
			 * <p>Transferring newly assigned ids to the original graph allows for continuing
			 * to use the original object graph, despite merged copies being registered with
			 * the current Hibernate Session. This is particularly useful for web applications
			 * that might want to store an object graph and then render it in a web view,
			 * with links that include the id of certain (potentially newly saved) objects.
			 *
			 * <p>The merge behavior given by this MergeEventListener is nearly identical
			 * to TopLink's merge behavior. See PetClinic for an example, which relies on
			 * ids being available for newly saved objects: the <code>HibernateClinic</code>
			 * and <code>TopLinkClinic</code> DAO implementations both use straight merge
			 * calls, with the Hibernate SessionFactory configuration specifying an
			 * <code>IdTransferringMergeEventListener</code>.
			 *
			 * <p>Typically specified as entry for LocalSessionFactoryBean's "eventListeners"
			 * map, with key "merge".
			 */
		 -->
		<property name="eventListeners">
        	<map>
	            <entry key="merge">
	                   <bean class="org.springframework.orm.hibernate3.support.IdTransferringMergeEventListener" />
	            </entry>
       		</map>
        </property>
		
		<!-- For TESTing & production Environment START -->
  <property name="mappingJarLocations" value="WEB-INF/lib/udaan-domain*.jar"/>  

	<!-- For TESTing & production Environment END -->

	<!-- For Development START -->
 	 <!-- <property name="mappingLocations">
                  <list>
            <value> classpath*:/**/*.hbm.xml</value>  
            </list>
            </property> -->
		<!-- For Development END -->



		<property name="hibernateProperties">
			<props>
				<prop key="hibernate.dialect">${hibernate.mysql.dialect}</prop>
				<prop key="hibernate.show_sql">${hibernate.show_sql}</prop>
				<prop key="hibernate.format_sql">${hibernate.format_sql}</prop>
				<prop key="hibernate.connection.autocommit">${hibernate.connection.autocommit}</prop>
				<prop key="hibernate.connection.release_mode">${hibernate.connection.release_mode}</prop>
				<!-- <prop key="hibernate.current_session_context_class">${hibernate.current_session_context_class}</prop>
				<prop key="hibernate.transaction.factory_class">${hibernate.transaction.factory_class}</prop> -->
			<!--  <prop key="hibernate.current_session_context_class">${hibernate.current_session_context_class}</prop> 
				<prop key="hibernate.transaction.factory_class">${hibernate.transaction.factory_class}</prop> -->
				<!-- enable second level cache and query cache -->
				<prop key="hibernate.cache.use_second_level_cache">true</prop>
				<prop key="net.sf.ehcache.configurationResourceName">udaan-hibernate-ehcache.xml</prop>
				<!-- <prop key="hibernate.cache.provider_configuration_file_resource_path">myehcache.xml</prop> -->
				<prop key="hibernate.cache.region.factory_class">net.sf.ehcache.hibernate.EhCacheRegionFactory</prop>
				<!-- to enable Query statistics <prop key="hibernate.generate_statistics">true</prop> -->
				<!-- It specifies whether entries will be written in a readable format 
					or not in the L2 cache. You probably should turn it on if you plan to browse 
					through the cache. <prop key="hibernate.cache.use_structured_entries">true</prop> -->
			</props>
		</property>

	</bean>


	<!-- Hibernate template for hibernateSessionFactory -->
	<bean id="hibernateTemplate" class="org.springframework.orm.hibernate3.HibernateTemplate">
		<property name="sessionFactory" ref="hibernateSessionFactory" />
	</bean>

	<!-- Transaction Manager for hibernateSessionFactory -->

	<bean id="transactionManager"
		class="org.springframework.orm.hibernate3.HibernateTransactionManager">
		<property name="sessionFactory" ref="hibernateSessionFactory" />
	</bean>
 

</beans>